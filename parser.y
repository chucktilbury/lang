%debug
%defines
%locations

%{
#include <stdio.h>
#include <stdint.h>
#include "str.h"
#include "scanner.h"

%}

%union {
    const char* str;
    double fnum;
    int64_t inum;
    uint64_t unum;
    int symbol;
    void* nterm;
};

%token NAMESPACE CLASS CREATE DESTROY
%token IF ELSE WHILE DO FOR IN TO TRY
%token EXCEPT RAISE RETURN EXIT SWITCH CASE YIELD TRACE PRINT IMPORT
%token NOT OR AND EQU NEQU LORE GORE TRUE FALSE BREAK CONTINUE
%token ENTRY MODULE
%token ADD_ASSIGN SUB_ASSIGN MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN
%token ASSIGN ADD SUB MUL DIV MOD DOT COMMA
%token OPOINT CPOINT CPAREN OPAREN OBLOCK CBLOCK OBRACE CBRACE

%token <str> SYMBOL STRG_CONST
%token <fnum> FLOAT_CONST
%token <inum> INT_CONST
%token <unum> UNSIGNED_CONST
%token <symbol> PUBLIC PRIVATE PROTECTED INTEGER UNSIGNED
%token <symbol> FLOAT STRING DICT LIST BOOLEAN NOTHING
%token <symbol> EXEC STATIC DYNAMIC

    /*
     *  These types are copied from the nterm.txt file, which is
     *  automatically generated by the build system.
     */
%type <nterm> module
%type <nterm> module_type
%type <nterm> module_element
%type <nterm> module_body
%type <nterm> scope
%type <nterm> compound_symbol
%type <nterm> compound_symbol_element
%type <nterm> namespace_definition
%type <nterm> namespace_body
%type <nterm> class_definition
%type <nterm> class_parameters
%type <nterm> class_block
%type <nterm> import_statement
    /*
     */

%define parse.error custom
%locations

%right ASSIGN
%right ADD_ASSIGN SUB_ASSIGN
%right MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN
%left CAST
%left OR
%left AND
%left EQU NEQU
%left LORE GORE OPOINT CPOINT
%left ADD SUB
%left MUL DIV MOD
%left NEGATE

%%

module
    : MODULE SYMBOL OPAREN module_type CPAREN module_body {}
    ;

    /*
        This is a comment that is not a hint:.
    */
module_type /* hint: combine_all terminals_only */
    : %empty {}
    | EXEC {}
    | STATIC {}
    | DYNAMIC {}
    ;

module_element /* hint: combine_all */
    : namespace_definition
    | class_definition
    | import_statement
    ;

module_body /* hint: is_a_list */
    : module_element
    | module_body module_element
    ;

scope /* hint: combine_all terminals_only */
    : %empty { printf("scope is PRIVATE\n"); }
    | PUBLIC { printf("scope is PUBLIC\n"); }
    | PRIVATE { printf("scope is PRIVATE\n"); }
    | PROTECTED { printf("scope is PROTECTED\n"); }
    ;

compound_symbol /* hint: is_a_list */
    : compound_symbol_element { printf("compound symbol create\n"); }
    | compound_symbol DOT compound_symbol_element { printf("compound symbol add\n"); }
    ;

compound_symbol_element /* hint: terminals_only */
    : SYMBOL { printf("compound symbol: \"%s\"\n", $1); }
    ;

namespace_definition
    : scope NAMESPACE SYMBOL OBLOCK namespace_body CBLOCK {
            printf("namespace definition: \"%s\"\n", $3);
        }
    ;

namespace_body /* hint: combine_all */
    : namespace_definition
    | class_definition
    ;

class_definition
    : scope CLASS SYMBOL class_parameters class_block {
            printf("class definition: \"%s\"\n", $3);
        }
    ;

class_parameters
    : %empty {}
    | OPAREN compound_symbol CPAREN {}
    ;

class_block
    : OBLOCK CBLOCK {
            printf("class block\n");
        }
    ;

import_statement
    : IMPORT compound_symbol {
            printf("import statement\n");
        }
    ;
%%

/*
 *  This converts terminal symbol definitions to strings for error handling.
 */
static const char *
symbol_name (yysymbol_kind_t yysymbol)
{
    return ((yysymbol == YYSYMBOL_YYEMPTY)? "empty":
        (yysymbol == YYSYMBOL_YYEOF)? "end of file" :
        (yysymbol == YYSYMBOL_YYerror)? "error" :
        (yysymbol == YYSYMBOL_YYUNDEF)? "invalid token" :
        (yysymbol == YYSYMBOL_NAMESPACE)? "NAMESPACE keyword" :
        (yysymbol == YYSYMBOL_CLASS)? "CLASS keyword" :
        (yysymbol == YYSYMBOL_PUBLIC)? "PUBLIC keyword" :
        (yysymbol == YYSYMBOL_PRIVATE)? "PRIVATE keyword" :
        (yysymbol == YYSYMBOL_PROTECTED)? "PROTECTED keyword" :
        (yysymbol == YYSYMBOL_CREATE)? "CREATE keyword" :
        (yysymbol == YYSYMBOL_DESTROY)? "DESTROY keyword" :
        (yysymbol == YYSYMBOL_INTEGER)? "INTEGER keyword" :
        (yysymbol == YYSYMBOL_UNSIGNED)? "UNSIGNED keyword" :
        (yysymbol == YYSYMBOL_FLOAT)? "FLOAT keyword" :
        (yysymbol == YYSYMBOL_STRING)? "STRING keyword" :
        (yysymbol == YYSYMBOL_DICT)? "DICT keyword" :
        (yysymbol == YYSYMBOL_LIST)? "LIST keyword" :
        (yysymbol == YYSYMBOL_BOOLEAN)? "BOOLEAN keyword" :
        (yysymbol == YYSYMBOL_NOTHING)? "NOTHING keyword" :
        (yysymbol == YYSYMBOL_IF)? "IF keyword" :
        (yysymbol == YYSYMBOL_ELSE)? "ELSE keyword" :
        (yysymbol == YYSYMBOL_WHILE)? "WHILE keyword" :
        (yysymbol == YYSYMBOL_DO)? "DO keyword" :
        (yysymbol == YYSYMBOL_FOR)? "FOR keyword" :
        (yysymbol == YYSYMBOL_IN)? "IN keyword" :
        (yysymbol == YYSYMBOL_TO)? "TO keyword" :
        (yysymbol == YYSYMBOL_TRY)? "TRY keyword" :
        (yysymbol == YYSYMBOL_EXCEPT)? "EXCEPT keyword" :
        (yysymbol == YYSYMBOL_RAISE)? "RAISE keyword" :
        (yysymbol == YYSYMBOL_RETURN)? "RETURN keyword" :
        (yysymbol == YYSYMBOL_EXIT)? "EXIT keyword" :
        (yysymbol == YYSYMBOL_SWITCH)? "SWITCH keyword" :
        (yysymbol == YYSYMBOL_CASE)? "CASE keyword" :
        (yysymbol == YYSYMBOL_YIELD)? "YIELD keyword" :
        (yysymbol == YYSYMBOL_TRACE)? "TRACE keyword" :
        (yysymbol == YYSYMBOL_PRINT)? "PRINT keyword" :
        (yysymbol == YYSYMBOL_IMPORT)? "IMPORT keyword" :
        (yysymbol == YYSYMBOL_CONTINUE)? "CONTINUE keyword" :
        (yysymbol == YYSYMBOL_ENTRY)? "ENTRY keyword" :
        (yysymbol == YYSYMBOL_MODULE)? "MODULE keyword" :
        (yysymbol == YYSYMBOL_EXEC)? "EXEC keyword" :
        (yysymbol == YYSYMBOL_STATIC)? "STATIC keyword" :
        (yysymbol == YYSYMBOL_DYNAMIC)? "DYNAMIC keyword" :
        (yysymbol == YYSYMBOL_BREAK)? "BREAK keyword" :
        (yysymbol == YYSYMBOL_TRUE)? "TRUE keyword" :
        (yysymbol == YYSYMBOL_FALSE)? "FALSE keyword" :
        (yysymbol == YYSYMBOL_NOT)? "NOT operator" :
        (yysymbol == YYSYMBOL_OR)? "OR operator" :
        (yysymbol == YYSYMBOL_AND)? "AND operator" :
        (yysymbol == YYSYMBOL_EQU)? "== operator" :
        (yysymbol == YYSYMBOL_NEQU)? "!= operator" :
        (yysymbol == YYSYMBOL_LORE)? "<= operator" :
        (yysymbol == YYSYMBOL_GORE)? ">= operator" :
        (yysymbol == YYSYMBOL_ADD_ASSIGN)? "+= operator" :
        (yysymbol == YYSYMBOL_SUB_ASSIGN)? "-= operator" :
        (yysymbol == YYSYMBOL_MUL_ASSIGN)? "*= operator" :
        (yysymbol == YYSYMBOL_DIV_ASSIGN)? "/= operator" :
        (yysymbol == YYSYMBOL_MOD_ASSIGN)? "%= operator" :
        (yysymbol == YYSYMBOL_ASSIGN)? "= operator" :
        (yysymbol == YYSYMBOL_ADD)? "+ operator" :
        (yysymbol == YYSYMBOL_SUB)? "- operator" :
        (yysymbol == YYSYMBOL_MUL)? "* operator" :
        (yysymbol == YYSYMBOL_DIV)? "/ operator" :
        (yysymbol == YYSYMBOL_MOD)? "% operator" :
        (yysymbol == YYSYMBOL_DOT)? ". operator" :
        (yysymbol == YYSYMBOL_COMMA)? "," :
        (yysymbol == YYSYMBOL_OPOINT)? "<" :
        (yysymbol == YYSYMBOL_CPOINT)? ">" :
        (yysymbol == YYSYMBOL_CPAREN)? ")" :
        (yysymbol == YYSYMBOL_OPAREN)? "(" :
        (yysymbol == YYSYMBOL_OBLOCK)? "{" :
        (yysymbol == YYSYMBOL_CBLOCK)? "}" :
        (yysymbol == YYSYMBOL_OBRACE)? "[" :
        (yysymbol == YYSYMBOL_CBRACE)? "]" :
        (yysymbol == YYSYMBOL_SYMBOL)? "Symbol" :
        (yysymbol == YYSYMBOL_STRG_CONST)? "String literal" :
        (yysymbol == YYSYMBOL_FLOAT_CONST)? "Float literal" :
        (yysymbol == YYSYMBOL_INT_CONST)? "Integer literal" :
        (yysymbol == YYSYMBOL_UNSIGNED_CONST)? "Unsigned literal" : "UNKNOWN");
}

/*
 * This looks hacky but it's official: I found it here:
 * https://www.gnu.org/software/bison/manual/html_node/Syntax-Error-Reporting-Function.html
 */
static int
yyreport_syntax_error (const yypcontext_t *ctx)
{
  int res = 0;
  //YYLOCATION_PRINT (stderr, yypcontext_location (ctx));
  fprintf(stderr, "%s:%d:%d: syntax error",
                get_file_name(), get_line_no(), get_col_no() );
  // Report the tokens expected at this point.
  {
    enum { TOKENMAX = 5 };
    yysymbol_kind_t expected[TOKENMAX];
    int n = yypcontext_expected_tokens (ctx, expected, TOKENMAX);
    if (n < 0)
      // Forward errors to yyparse.
      res = n;
    else
      for (int i = 0; i < n; ++i)
        fprintf (stderr, "%s %s",
                 i == 0 ? ": expected" : " or", symbol_name (expected[i]));
  }
  // Report the unexpected token.
  {
    yysymbol_kind_t lookahead = yypcontext_token (ctx);
    if (lookahead != YYSYMBOL_YYEMPTY)
      fprintf (stderr, " before %s", symbol_name (lookahead));
  }
  fprintf (stderr, "\n");
  return res;
}

void yyerror(const char* s) {

    fprintf(stderr, "%s:%d:%d %s\n",
            get_file_name(), get_line_no(), get_col_no(), s);
    //error("%s", s);
}

const char* tokenToStr(int tok) {
    // This is the official way...
    return yysymbol_name(YYTRANSLATE(tok));
}

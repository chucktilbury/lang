%debug
%defines
%locations

%{
#include <stdio.h>
#include <stdint.h>
#include "str.h"
#include "ast.h"
#include "scanner.h"

ast_module_t* ast_module_root = NULL;

%}

%union {
    const char* str;
    double fnum;
    int64_t inum;
    uint64_t unum;
    int symbol;
    void* nterm;
};

%token NAMESPACE CLASS CREATE DESTROY
%token IF ELSE WHILE DO FOR IN TO TRY
%token EXCEPT RAISE RETURN EXIT SWITCH CASE YIELD TRACE PRINT IMPORT
%token NOT OR AND EQU NEQU LORE GORE TRUE FALSE BREAK CONTINUE
%token ENTRY MODULE
%token ADD_ASSIGN SUB_ASSIGN MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN
%token ASSIGN ADD SUB MUL DIV MOD POW DOT COMMA
%token OPOINT CPOINT CPAREN OPAREN OBLOCK CBLOCK OBRACE CBRACE

%token <str> SYMBOL STRG_CONST
%token <fnum> FLOAT_CONST
%token <inum> INT_CONST
%token <unum> UNSIGNED_CONST
%token <symbol> PUBLIC PRIVATE PROTECTED INTEGER UNSIGNED
%token <symbol> FLOAT STRING DICT LIST BOOLEAN NOTHING
%token <symbol> EXEC STATIC DYNAMIC

    /*
     *  These types are copied from the nterm.txt file, which is
     *  automatically generated by the build system.
     */
%type <nterm> module
%type <nterm> module_type
%type <nterm> module_element
%type <nterm> module_body
%type <nterm> scope
%type <nterm> compound_symbol
%type <nterm> compound_symbol_element
%type <nterm> namespace_definition
%type <nterm> namespace_block
%type <nterm> namespace_element
%type <nterm> class_definition
%type <nterm> class_parameters
%type <nterm> class_block
%type <nterm> import_statement
    /*
     */

%define parse.error custom
%locations

    /*
        %right ASSIGN
        %right ADD_ASSIGN SUB_ASSIGN
        %right MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN
        %left CAST
        %left OR
        %left AND
        %left EQU NEQU
        %left LORE GORE OPOINT CPOINT
        %left ADD SUB
        %left MUL DIV MOD
        %precedence NEGATE
        %right POW
    */

%%
    /*
        This is a comment that is not a hint:.
    */

module /* hint: nothing */
    : MODULE SYMBOL OPAREN module_type CPAREN module_body {
            $$ = (void*)create_module();
            ((struct _ast_module_t_*)$$)->SYMBOL = $2;
            ((struct _ast_module_t_*)$$)->module_type = $4;
            ((struct _ast_module_t_*)$$)->module_body = $6;
            ast_module_root = $$; // return value from the parser.
        }
    ;

module_type /* hint: combine_terms */
    : %empty {
            $$ = (void*)create_module_type();
            ((struct _ast_module_type_t_*)$$)->terms = EXEC;
        }
    | EXEC {
            $$ = (void*)create_module_type();
            ((struct _ast_module_type_t_*)$$)->terms = $1;
        }
    | STATIC {
            $$ = (void*)create_module_type();
            ((struct _ast_module_type_t_*)$$)->terms = $1;
        }
    | DYNAMIC {
            $$ = (void*)create_module_type();
            ((struct _ast_module_type_t_*)$$)->terms = $1;
        }
    ;

module_element /* hint: combine_nterms list_element */
    : namespace_definition {
            $$ = (void*)create_module_element();
           ((struct _ast_module_element_t_*)$$)->nterms = $1;
           ((struct _ast_module_element_t_*)$$)->next = NULL;
        }
    | class_definition {
            $$ = (void*)create_module_element();
           ((struct _ast_module_element_t_*)$$)->nterms = $1;
           ((struct _ast_module_element_t_*)$$)->next = NULL;
        }
    | import_statement {
            $$ = (void*)create_module_element();
           ((struct _ast_module_element_t_*)$$)->nterms = $1;
           ((struct _ast_module_element_t_*)$$)->next = NULL;
        }
    ;

module_body /* hint: is_list */
    : module_element {
            $$ = (void*)create_module_body();
           ((struct _ast_module_body_t_*)$$)->first = $1;
           ((struct _ast_module_body_t_*)$$)->last = $1;
        }
    | module_body module_element {
            add_module_body((struct _ast_module_body_t_*)$$, $2);
        }
    ;

scope /* hint: combine_terms*/
    : %empty {
            $$ = (void*)create_scope();
           ((struct _ast_scope_t_*)$$)->terms = PRIVATE;
        }
    | PUBLIC {
            $$ = (void*)create_scope();
           ((struct _ast_scope_t_*)$$)->terms = $1;
        }
    | PRIVATE {
            $$ = (void*)create_scope();
           ((struct _ast_scope_t_*)$$)->terms = $1;
        }
    | PROTECTED {
            $$ = (void*)create_scope();
           ((struct _ast_scope_t_*)$$)->terms = $1;
        }
    ;

compound_symbol /* hint: is_list */
    : compound_symbol_element {
            $$ = (void*)create_compound_symbol();
           ((struct _ast_compound_symbol_t_*)$$)->first = $1;
           ((struct _ast_compound_symbol_t_*)$$)->last = $1;
        }
    | compound_symbol DOT compound_symbol_element {
            add_compound_symbol((struct _ast_compound_symbol_t_*)$$, $3);
        }
    ;

compound_symbol_element /* hint: combine_nterms list_element */
    : SYMBOL {
            $$ = (void*)create_compound_symbol_element();
           ((struct _ast_compound_symbol_element_t_*)$$)->terms = $1;
           ((struct _ast_compound_symbol_element_t_*)$$)->next = NULL;
        }
    | func_reference
    | array_reference
    ;

func_reference /* hint: nothing */
    : SYMBOL OPAREN expr_list CPAREN
    ;

array_reference /* hint: nothing */
    : SYMBOL OBRACE array_index CBRACE
    ;

array_index /* hint: nothing */
    : expression
    | array_reference
    ;

import_statement /* hint: nothing */
    : IMPORT compound_symbol {
            $$ = (void*)create_import_statement();
           ((struct _ast_import_statement_t_*)$$)->compound_symbol = $2;
        }
    ;

namespace_definition /* hint: nothing */
    : scope NAMESPACE SYMBOL OBLOCK namespace_block CBLOCK {
            $$ = (void*)create_namespace_definition();
           ((struct _ast_namespace_definition_t_*)$$)->SYMBOL = $3;
           ((struct _ast_namespace_definition_t_*)$$)->scope = $1;
           ((struct _ast_namespace_definition_t_*)$$)->namespace_block = $5;
        }
    ;

namespace_block /* hint: is_list */
    : namespace_element {
            $$ = (void*)create_namespace_block();
           ((struct _ast_namespace_block_t_*)$$)->first = $1;
           ((struct _ast_namespace_block_t_*)$$)->last = $1;
        }
    | namespace_block namespace_element {
            add_namespace_block((struct _ast_namespace_block_t_*)$$, $2);
        }
    ;

namespace_element /* hint: combine_nterms list_element */
    : namespace_definition {
            $$ = (void*)create_namespace_element();
           ((struct _ast_namespace_element_t_*)$$)->nterms = $1;
           ((struct _ast_namespace_element_t_*)$$)->next = NULL;
        }
    | class_definition {
            $$ = (void*)create_namespace_element();
           ((struct _ast_namespace_element_t_*)$$)->nterms = $1;
           ((struct _ast_namespace_element_t_*)$$)->next = NULL;
        }
    ;

class_definition /* hint: nothing */
    : scope CLASS SYMBOL class_parameters class_block {
            $$ = (void*)create_class_definition();
           ((struct _ast_class_definition_t_*)$$)->SYMBOL = $3;
           ((struct _ast_class_definition_t_*)$$)->scope = $1;
           ((struct _ast_class_definition_t_*)$$)->class_parameters = $4;
           ((struct _ast_class_definition_t_*)$$)->class_block = $5;
        }
    ;

class_parameters /* hint: nothing */
    : %empty {
            $$ = (void*)create_class_parameters();
           ((struct _ast_class_parameters_t_*)$$)->compound_symbol = NULL;
        }
    | OPAREN CPAREN {
            $$ = (void*)create_class_parameters();
           ((struct _ast_class_parameters_t_*)$$)->compound_symbol = NULL;
        }
    | OPAREN compound_symbol CPAREN {
            $$ = (void*)create_class_parameters();
           ((struct _ast_class_parameters_t_*)$$)->compound_symbol = $2;
        }
    ;

class_block /* hint: nothing */
    : OBLOCK CBLOCK {
            $$ = (void*)create_class_block();
        }
    ;

primary /* hint: nothing */
    : compound_symbol
    | STRG_CONST
    | FLOAT_CONST
    | INT_CONST
    | UNSIGNED_CONST
    | OPAREN expression CPAREN
    ;

expression /* hint: binary_op */
    : expression AND comp
    | expression OR comp
    | comp
    ;

comp /* hint: binary_op */
    : comp EQU ltgt
    | comp NEQU ltgt
    | ltgt
    ;

ltgt /* hint: binary_op */
    : ltgt LORE term
    | ltgt GORE term
    | ltgt OPOINT term
    | ltgt CPOINT term
    | term
    ;

term /* hint: binary_op */
    : term ADD factor
    | term SUB factor
    | factor
    ;

factor /* hint: binary_op */
    : factor MUL unary
    | factor DIV unary
    | factor MOD unary
    | factor POW unary
    | unary
    ;

unary /* hint: unary_op */
    : NOT unary
    | SUB unary
    | primary
    ;

expr_list /* hint: is_list */
    : expression
    | expr_list COMMA expression
    ;

%%

/*
 *  This converts terminal symbol definitions to strings for error handling.
 */
static const char *
symbol_name (yysymbol_kind_t yysymbol)
{
    return ((yysymbol == YYSYMBOL_YYEMPTY)? "empty":
        (yysymbol == YYSYMBOL_YYEOF)? "end of file" :
        (yysymbol == YYSYMBOL_YYerror)? "error" :
        (yysymbol == YYSYMBOL_YYUNDEF)? "invalid token" :
        (yysymbol == YYSYMBOL_NAMESPACE)? "NAMESPACE keyword" :
        (yysymbol == YYSYMBOL_CLASS)? "CLASS keyword" :
        (yysymbol == YYSYMBOL_PUBLIC)? "PUBLIC keyword" :
        (yysymbol == YYSYMBOL_PRIVATE)? "PRIVATE keyword" :
        (yysymbol == YYSYMBOL_PROTECTED)? "PROTECTED keyword" :
        (yysymbol == YYSYMBOL_CREATE)? "CREATE keyword" :
        (yysymbol == YYSYMBOL_DESTROY)? "DESTROY keyword" :
        (yysymbol == YYSYMBOL_INTEGER)? "INTEGER keyword" :
        (yysymbol == YYSYMBOL_UNSIGNED)? "UNSIGNED keyword" :
        (yysymbol == YYSYMBOL_FLOAT)? "FLOAT keyword" :
        (yysymbol == YYSYMBOL_STRING)? "STRING keyword" :
        (yysymbol == YYSYMBOL_DICT)? "DICT keyword" :
        (yysymbol == YYSYMBOL_LIST)? "LIST keyword" :
        (yysymbol == YYSYMBOL_BOOLEAN)? "BOOLEAN keyword" :
        (yysymbol == YYSYMBOL_NOTHING)? "NOTHING keyword" :
        (yysymbol == YYSYMBOL_IF)? "IF keyword" :
        (yysymbol == YYSYMBOL_ELSE)? "ELSE keyword" :
        (yysymbol == YYSYMBOL_WHILE)? "WHILE keyword" :
        (yysymbol == YYSYMBOL_DO)? "DO keyword" :
        (yysymbol == YYSYMBOL_FOR)? "FOR keyword" :
        (yysymbol == YYSYMBOL_IN)? "IN keyword" :
        (yysymbol == YYSYMBOL_TO)? "TO keyword" :
        (yysymbol == YYSYMBOL_TRY)? "TRY keyword" :
        (yysymbol == YYSYMBOL_EXCEPT)? "EXCEPT keyword" :
        (yysymbol == YYSYMBOL_RAISE)? "RAISE keyword" :
        (yysymbol == YYSYMBOL_RETURN)? "RETURN keyword" :
        (yysymbol == YYSYMBOL_EXIT)? "EXIT keyword" :
        (yysymbol == YYSYMBOL_SWITCH)? "SWITCH keyword" :
        (yysymbol == YYSYMBOL_CASE)? "CASE keyword" :
        (yysymbol == YYSYMBOL_YIELD)? "YIELD keyword" :
        (yysymbol == YYSYMBOL_TRACE)? "TRACE keyword" :
        (yysymbol == YYSYMBOL_PRINT)? "PRINT keyword" :
        (yysymbol == YYSYMBOL_IMPORT)? "IMPORT keyword" :
        (yysymbol == YYSYMBOL_CONTINUE)? "CONTINUE keyword" :
        (yysymbol == YYSYMBOL_ENTRY)? "ENTRY keyword" :
        (yysymbol == YYSYMBOL_MODULE)? "MODULE keyword" :
        (yysymbol == YYSYMBOL_EXEC)? "EXEC keyword" :
        (yysymbol == YYSYMBOL_STATIC)? "STATIC keyword" :
        (yysymbol == YYSYMBOL_DYNAMIC)? "DYNAMIC keyword" :
        (yysymbol == YYSYMBOL_BREAK)? "BREAK keyword" :
        (yysymbol == YYSYMBOL_TRUE)? "TRUE keyword" :
        (yysymbol == YYSYMBOL_FALSE)? "FALSE keyword" :
        (yysymbol == YYSYMBOL_NOT)? "NOT operator" :
        (yysymbol == YYSYMBOL_OR)? "OR operator" :
        (yysymbol == YYSYMBOL_AND)? "AND operator" :
        (yysymbol == YYSYMBOL_EQU)? "== operator" :
        (yysymbol == YYSYMBOL_NEQU)? "!= operator" :
        (yysymbol == YYSYMBOL_LORE)? "<= operator" :
        (yysymbol == YYSYMBOL_GORE)? ">= operator" :
        (yysymbol == YYSYMBOL_ADD_ASSIGN)? "+= operator" :
        (yysymbol == YYSYMBOL_SUB_ASSIGN)? "-= operator" :
        (yysymbol == YYSYMBOL_MUL_ASSIGN)? "*= operator" :
        (yysymbol == YYSYMBOL_DIV_ASSIGN)? "/= operator" :
        (yysymbol == YYSYMBOL_MOD_ASSIGN)? "%= operator" :
        (yysymbol == YYSYMBOL_ASSIGN)? "= operator" :
        (yysymbol == YYSYMBOL_ADD)? "+ operator" :
        (yysymbol == YYSYMBOL_SUB)? "- operator" :
        (yysymbol == YYSYMBOL_MUL)? "* operator" :
        (yysymbol == YYSYMBOL_DIV)? "/ operator" :
        (yysymbol == YYSYMBOL_MOD)? "% operator" :
        (yysymbol == YYSYMBOL_DOT)? ". operator" :
        (yysymbol == YYSYMBOL_COMMA)? "," :
        (yysymbol == YYSYMBOL_OPOINT)? "<" :
        (yysymbol == YYSYMBOL_CPOINT)? ">" :
        (yysymbol == YYSYMBOL_CPAREN)? ")" :
        (yysymbol == YYSYMBOL_OPAREN)? "(" :
        (yysymbol == YYSYMBOL_OBLOCK)? "{" :
        (yysymbol == YYSYMBOL_CBLOCK)? "}" :
        (yysymbol == YYSYMBOL_OBRACE)? "[" :
        (yysymbol == YYSYMBOL_CBRACE)? "]" :
        (yysymbol == YYSYMBOL_SYMBOL)? "Symbol" :
        (yysymbol == YYSYMBOL_STRG_CONST)? "String literal" :
        (yysymbol == YYSYMBOL_FLOAT_CONST)? "Float literal" :
        (yysymbol == YYSYMBOL_INT_CONST)? "Integer literal" :
        (yysymbol == YYSYMBOL_UNSIGNED_CONST)? "Unsigned literal" : "UNKNOWN");
}

/*
 * This looks hacky but it's official: I found it here:
 * https://www.gnu.org/software/bison/manual/html_node/Syntax-Error-Reporting-Function.html
 */
static int
yyreport_syntax_error (const yypcontext_t *ctx)
{
  int res = 0;
  //YYLOCATION_PRINT (stderr, yypcontext_location (ctx));
  fprintf(stderr, "%s:%d:%d: syntax error",
                get_file_name(), get_line_no(), get_col_no() );
  // Report the tokens expected at this point.
  {
    enum { TOKENMAX = 5 };
    yysymbol_kind_t expected[TOKENMAX];
    int n = yypcontext_expected_tokens (ctx, expected, TOKENMAX);
    if (n < 0)
      // Forward errors to yyparse.
      res = n;
    else
      for (int i = 0; i < n; ++i)
        fprintf (stderr, "%s %s",
                 i == 0 ? ": expected" : " or", symbol_name (expected[i]));
  }
  // Report the unexpected token.
  {
    yysymbol_kind_t lookahead = yypcontext_token (ctx);
    if (lookahead != YYSYMBOL_YYEMPTY)
      fprintf (stderr, " before %s", symbol_name (lookahead));
  }
  fprintf (stderr, "\n");
  return res;
}

void yyerror(const char* s) {

    fprintf(stderr, "%s:%d:%d %s\n",
            get_file_name(), get_line_no(), get_col_no(), s);
    //error("%s", s);
}

const char* tokenToStr(int tok) {
    // This is the official way...
    return yysymbol_name(YYTRANSLATE(tok));
}
